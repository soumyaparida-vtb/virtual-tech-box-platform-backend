{
  "id": "devops-git-advanced",
  "title": "Advanced Git & Version Control",
  "description": "Master advanced Git workflows, branching strategies, and collaborative development practices essential for DevOps",
  "order": 3,
  "estimatedMinutes": 75,
  "lessons": [
    {
      "id": "devops-git-1",
      "title": "Git Branching Strategies",
      "type": "text",
      "content": "# Git Branching Strategies for DevOps\n\nEffective branching strategies are crucial for successful DevOps implementations. They enable parallel development, feature isolation, and smooth releases.\n\n## Common Branching Models\n\n### 1. Git Flow\n\nGit Flow is a branching model that defines specific branch types and their purposes:\n\n- **main/master**: Production-ready code\n- **develop**: Integration branch for features\n- **feature/***: Individual feature development\n- **release/***: Preparing new releases\n- **hotfix/***: Emergency fixes for production\n\n```bash\n# Create a new feature branch\ngit checkout develop\ngit checkout -b feature/user-authentication\n\n# Work on the feature\ngit add .\ngit commit -m \"Add user login functionality\"\n\n# Merge back to develop\ngit checkout develop\ngit merge feature/user-authentication\ngit branch -d feature/user-authentication\n```\n\n### 2. GitHub Flow\n\nA simpler model used by GitHub:\n\n- **main**: Always deployable\n- **feature branches**: Short-lived branches for changes\n- **Pull Requests**: Code review and integration\n\n```bash\n# Create and push feature branch\ngit checkout -b feature/api-improvements\ngit push -u origin feature/api-improvements\n\n# Create pull request via GitHub UI\n# After review and approval, merge and delete branch\n```\n\n### 3. GitLab Flow\n\nCombines feature-driven development with issue tracking:\n\n- **main**: Latest stable version\n- **production**: What's currently deployed\n- **feature branches**: Linked to issues\n\n## Choosing the Right Strategy\n\n| **Strategy** | **Team Size** | **Release Frequency** | **Complexity** |\n|--------------|---------------|----------------------|----------------|\n| Git Flow | Large (10+) | Scheduled releases | High |\n| GitHub Flow | Small-Medium | Continuous deployment | Low |\n| GitLab Flow | Medium | Regular releases | Medium |\n\n## Branch Protection Rules\n\nProtect important branches with rules:\n\n- Require pull request reviews\n- Require status checks to pass\n- Require branches to be up to date\n- Restrict pushes to specific people\n- Require signed commits\n\n## Best Practices\n\n1. **Use descriptive branch names**: `feature/user-auth`, `bugfix/login-error`\n2. **Keep branches short-lived**: Merge within days, not weeks\n3. **Regular synchronization**: Frequently pull from main/develop\n4. **Clean commit history**: Use rebase for linear history\n5. **Delete merged branches**: Keep repository clean\n\n## DevOps Integration\n\nBranching strategies should align with your CI/CD pipeline:\n\n- **Feature branches**: Trigger test suites\n- **Develop branch**: Deploy to staging environments\n- **Main branch**: Deploy to production\n- **Release branches**: Deploy to pre-production testing\n\nNext, we'll explore how to implement effective code review processes.",
      "resources": [
        {
          "title": "Git Flow vs GitHub Flow",
          "url": "https://lucamezzalira.com/2014/03/10/git-flow-vs-github-flow/",
          "type": "article"
        },
        {
          "title": "A successful Git branching model",
          "url": "https://nvie.com/posts/a-successful-git-branching-model/",
          "type": "article"
        }
      ]
    },
    {
      "id": "devops-git-2",
      "title": "Code Review & Collaboration",
      "type": "text",
      "content": "# Code Review & Collaboration in DevOps\n\nCode reviews are a cornerstone of quality software development and essential for successful DevOps practices. They ensure code quality, knowledge sharing, and early bug detection.\n\n## The Code Review Process\n\n### 1. Preparation\n\nBefore submitting code for review:\n\n- **Self-review first**: Check your own code thoroughly\n- **Write clear commit messages**: Explain what and why\n- **Keep changes focused**: One feature or fix per PR\n- **Add tests**: Ensure your code is testable\n- **Update documentation**: Keep docs current\n\n### 2. Creating Effective Pull Requests\n\n```markdown\n## Description\nBrief description of changes and motivation\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Testing\n- [ ] Unit tests added/updated\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] Self-review completed\n- [ ] Documentation updated\n- [ ] No merge conflicts\n```\n\n### 3. Review Guidelines\n\n**For Reviewers:**\n- Focus on logic, not style (use linters for style)\n- Ask questions rather than make demands\n- Provide constructive feedback\n- Approve if code improves the codebase\n- Consider the bigger picture\n\n**For Authors:**\n- Respond to all comments\n- Ask for clarification if needed\n- Be open to feedback\n- Make requested changes promptly\n- Thank reviewers for their time\n\n## Collaboration Tools\n\n### GitHub Pull Requests\n\n```bash\n# Create PR from command line using GitHub CLI\ngh pr create --title \"Add user authentication\" --body \"Implements login/logout functionality\"\n\n# Review and merge\ngh pr review --approve\ngh pr merge --squash\n```\n\n### GitLab Merge Requests\n\n```bash\n# Push and create MR\ngit push -o merge_request.create \\\n  -o merge_request.title=\"Feature: User Authentication\" \\\n  -o merge_request.description=\"Detailed description here\"\n```\n\n## Automated Code Quality\n\n### Pre-commit Hooks\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n        language_version: python3\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n```\n\n### Code Quality Gates\n\n- **Code coverage thresholds**: Maintain >80% coverage\n- **Security scanning**: Detect vulnerabilities early\n- **Performance testing**: Prevent performance regressions\n- **Dependency scanning**: Check for outdated packages\n\n## DevOps Metrics for Code Review\n\nTrack these metrics to improve your process:\n\n1. **Review time**: Time from PR creation to merge\n2. **Review participation**: Number of reviewers per PR\n3. **Change failure rate**: Bugs introduced by changes\n4. **Deployment frequency**: How often code is released\n5. **Lead time**: Time from commit to production\n\n## Common Anti-patterns\n\n❌ **Avoid these practices:**\n- Rubber-stamp approvals without actual review\n- Nitpicking on minor style issues\n- Reviewing huge pull requests (>400 lines)\n- Blocking PRs for non-critical issues\n- Personal attacks or unconstructive criticism\n\n✅ **Best practices:**\n- Timely reviews (within 24 hours)\n- Focus on functionality and maintainability\n- Use automated tools for style/formatting\n- Constructive and specific feedback\n- Knowledge sharing through reviews\n\n## Integration with CI/CD\n\nCode reviews should integrate seamlessly with your pipeline:\n\n```yaml\n# GitHub Actions workflow\nname: Code Review Checks\non:\n  pull_request:\n    branches: [main, develop]\n\njobs:\n  quality-checks:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run linter\n        run: npm run lint\n      - name: Run tests\n        run: npm test\n      - name: Security scan\n        run: npm audit\n      - name: Code coverage\n        run: npm run coverage\n```\n\nEffective code reviews create a culture of quality and continuous improvement, essential for DevOps success.",
      "resources": [
        {
          "title": "Best Practices for Code Review",
          "url": "https://google.github.io/eng-practices/review/",
          "type": "documentation"
        },
        {
          "title": "Pre-commit Hooks",
          "url": "https://pre-commit.com/",
          "type": "documentation"
        }
      ]
    },
    {
      "id": "devops-git-3",
      "title": "Git Hooks & Automation",
      "type": "code",
      "content": "# Git Hooks & Automation\n\nGit hooks are scripts that Git executes before or after events such as commits, pushes, and receives. They're powerful tools for automating quality checks and enforcing team standards.\n\n## Types of Git Hooks\n\n### Client-side Hooks\n\nRun on the developer's machine:\n\n- **pre-commit**: Before commit is created\n- **prepare-commit-msg**: Before commit message editor\n- **commit-msg**: After commit message is entered\n- **post-commit**: After commit is completed\n- **pre-push**: Before pushing to remote\n\n### Server-side Hooks\n\nRun on the Git server:\n\n- **pre-receive**: Before any references are updated\n- **update**: For each branch being updated\n- **post-receive**: After all references are updated\n\n## Implementing Git Hooks\n\n### Pre-commit Hook Example\n\n```bash\n#!/bin/sh\n# .git/hooks/pre-commit\n\n# Run linter\necho \"Running linter...\"\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Linting failed. Please fix the issues.\"\n  exit 1\nfi\n\n# Run tests\necho \"Running tests...\"\nnpm test\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Please fix the failing tests.\"\n  exit 1\nfi\n\n# Check for debugging statements\necho \"Checking for debugging statements...\"\nif grep -r \"console.log\\|debugger\" src/; then\n  echo \"Please remove debugging statements before committing.\"\n  exit 1\nfi\n\necho \"Pre-commit checks passed!\"\nexit 0\n```\n\n### Commit Message Hook\n\n```bash\n#!/bin/sh\n# .git/hooks/commit-msg\n\n# Check commit message format\ncommit_regex='^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?!?: .{1,50}'\n\nif ! grep -qE \"$commit_regex\" \"$1\"; then\n  echo \"Invalid commit message format!\"\n  echo \"Format: type(scope): description\"\n  echo \"Types: feat, fix, docs, style, refactor, test, chore\"\n  echo \"Example: feat(auth): add user login functionality\"\n  exit 1\nfi\n\n# Check message length\nif [ $(head -n1 \"$1\" | wc -c) -gt 72 ]; then\n  echo \"Commit message too long (>72 characters)\"\n  exit 1\nfi\n\nexit 0\n```\n\n## Pre-commit Framework\n\nThe pre-commit framework provides a better way to manage hooks:\n\n### Installation and Setup\n\n```bash\n# Install pre-commit\npip install pre-commit\n\n# Create configuration file\ntouch .pre-commit-config.yaml\n\n# Install hooks\npre-commit install\n```\n\n### Configuration Example\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  # Built-in hooks\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-json\n      - id: check-added-large-files\n        args: ['--maxkb=1000']\n      - id: no-commit-to-branch\n        args: [--branch, main, --branch, master]\n\n  # Python hooks\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n        language_version: python3\n        args: [--line-length=88]\n\n  - repo: https://github.com/pycqa/isort\n    rev: 5.11.4\n    hooks:\n      - id: isort\n        args: [--profile, black]\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n        args: [--max-line-length=88, --extend-ignore=E203]\n\n  # JavaScript/TypeScript hooks\n  - repo: https://github.com/pre-commit/mirrors-eslint\n    rev: v8.28.0\n    hooks:\n      - id: eslint\n        files: \\.(js|ts|jsx|tsx)$\n        types: [file]\n        additional_dependencies:\n          - eslint@8.28.0\n          - '@typescript-eslint/parser@5.45.0'\n\n  # Security scanning\n  - repo: https://github.com/Yelp/detect-secrets\n    rev: v1.4.0\n    hooks:\n      - id: detect-secrets\n        args: ['--baseline', '.secrets.baseline']\n        exclude: package.lock.json\n\n  # Docker hooks\n  - repo: https://github.com/hadolint/hadolint\n    rev: v2.12.0\n    hooks:\n      - id: hadolint-docker\n        args: [--ignore, DL3008, --ignore, DL3009]\n```\n\n### Running Hooks\n\n```bash\n# Run on all files\npre-commit run --all-files\n\n# Run specific hook\npre-commit run black\n\n# Skip hooks for emergency commits\ngit commit -m \"Emergency fix\" --no-verify\n\n# Update hook versions\npre-commit autoupdate\n```\n\n## Advanced Automation\n\n### Custom Hook Scripts\n\n```python\n#!/usr/bin/env python3\n# scripts/check-dependencies.py\n\nimport json\nimport subprocess\nimport sys\nfrom datetime import datetime, timedelta\n\ndef check_outdated_dependencies():\n    \"\"\"Check for outdated npm dependencies\"\"\"\n    try:\n        result = subprocess.run(\n            ['npm', 'outdated', '--json'],\n            capture_output=True,\n            text=True\n        )\n        \n        if result.returncode == 0:\n            return True  # No outdated dependencies\n        \n        outdated = json.loads(result.stdout)\n        critical_packages = ['react', 'express', 'lodash']\n        \n        for package in outdated:\n            if package in critical_packages:\n                print(f\"Critical package {package} is outdated!\")\n                return False\n        \n        return True\n    \n    except Exception as e:\n        print(f\"Error checking dependencies: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    if not check_outdated_dependencies():\n        sys.exit(1)\n```\n\n### Server-side Hook Example\n\n```bash\n#!/bin/sh\n# Server-side post-receive hook\n# Deploys to staging when code is pushed to develop branch\n\nwhile read oldrev newrev refname; do\n    branch=$(git rev-parse --symbolic --abbrev-ref $refname)\n    \n    if [ \"$branch\" = \"develop\" ]; then\n        echo \"Deploying to staging environment...\"\n        \n        # Deploy to staging\n        cd /path/to/staging\n        git pull origin develop\n        \n        # Install dependencies\n        npm install --production\n        \n        # Run database migrations\n        npm run migrate\n        \n        # Restart application\n        pm2 restart staging-app\n        \n        # Run smoke tests\n        npm run smoke-test:staging\n        \n        if [ $? -eq 0 ]; then\n            echo \"Staging deployment successful!\"\n        else\n            echo \"Staging deployment failed!\"\n            # Rollback logic here\n        fi\n    fi\ndone\n```\n\n## Integration with CI/CD\n\nGit hooks complement CI/CD pipelines:\n\n```yaml\n# .github/workflows/quality-gates.yml\nname: Quality Gates\n\non:\n  pull_request:\n    branches: [main, develop]\n  push:\n    branches: [main, develop]\n\njobs:\n  quality-checks:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: npm\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run pre-commit hooks\n        uses: pre-commit/action@v3.0.0\n        \n      - name: Run tests with coverage\n        run: npm run test:coverage\n        \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        \n      - name: Security audit\n        run: npm audit --audit-level=high\n        \n      - name: Build application\n        run: npm run build\n```\n\nGit hooks provide the first line of defense in maintaining code quality, while CI/CD pipelines provide comprehensive testing and deployment automation.",
      "codeExamples": [
        {
          "language": "bash",
          "code": "#!/bin/sh\n# Simple pre-commit hook\n\n# Check for merge conflict markers\nif grep -r \"<<<<<<< HEAD\" .; then\n    echo \"Merge conflict markers found!\"\n    exit 1\nfi\n\n# Check for TODO comments\nif grep -r \"TODO\\|FIXME\" src/; then\n    echo \"Please resolve TODO/FIXME comments\"\n    exit 1\nfi\n\necho \"Pre-commit checks passed!\"\nexit 0",
          "title": "Basic Pre-commit Hook",
          "description": "A simple pre-commit hook that checks for merge conflicts and TODO comments"
        },
        {
          "language": "yaml",
          "code": "# .pre-commit-config.yaml for Python projects\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n      \n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n        \n  - repo: https://github.com/pycqa/flake8\n    rev: 5.0.4\n    hooks:\n      - id: flake8\n        args: [--max-line-length=88]",
          "title": "Pre-commit Configuration",
          "description": "Complete pre-commit configuration for Python projects with formatting and linting"
        }
      ],
      "resources": [
        {
          "title": "Git Hooks Documentation",
          "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks",
          "type": "documentation"
        },
        {
          "title": "Pre-commit Framework",
          "url": "https://pre-commit.com/",
          "type": "documentation"
        }
      ]
    },
    {
      "id": "devops-git-4",
      "title": "Git in CI/CD Pipelines",
      "type": "interactive",
      "content": "# Git in CI/CD Pipelines\n\nIntegrating Git effectively with CI/CD pipelines is crucial for DevOps success. This lesson covers Git strategies that enable smooth automated deployments.\n\n## Git Flow for CI/CD\n\n### Branch-based Deployments\n\nDifferent branches trigger different deployment stages:\n\n```yaml\n# GitHub Actions example\nname: Deploy\non:\n  push:\n    branches:\n      - main        # Deploy to production\n      - develop     # Deploy to staging\n      - feature/*   # Deploy to review environments\n\njobs:\n  deploy-production:\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: Deploy to Production\n        run: echo \"Deploying to production\"\n        \n  deploy-staging:\n    if: github.ref == 'refs/heads/develop'\n    runs-on: ubuntu-latest\n    environment: staging\n    steps:\n      - name: Deploy to Staging\n        run: echo \"Deploying to staging\"\n        \n  deploy-review:\n    if: startsWith(github.ref, 'refs/heads/feature/')\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy Review Environment\n        run: echo \"Deploying review environment\"\n```\n\n### Tag-based Releases\n\n```yaml\n# Release on tag creation\nname: Release\non:\n  push:\n    tags:\n      - 'v*.*.*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        \n      - name: Get version from tag\n        id: version\n        run: echo \"VERSION=${GITHUB_REF#refs/tags/}\" >> $GITHUB_OUTPUT\n        \n      - name: Build and push Docker image\n        run: |\n          docker build -t myapp:${{ steps.version.outputs.VERSION }} .\n          docker push myapp:${{ steps.version.outputs.VERSION }}\n```\n\n## Semantic Versioning with Git\n\n### Conventional Commits\n\nStructured commit messages enable automated versioning:\n\n```\nfeat: add user authentication (MINOR version bump)\nfix: resolve login bug (PATCH version bump)\nfeat!: change API structure (MAJOR version bump)\ndocs: update README (no version bump)\n```\n\n### Automated Version Bumping\n\n```yaml\n# Semantic Release workflow\nname: Release\non:\n  push:\n    branches: [main]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Semantic Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: npx semantic-release\n```\n\n## Git Operations in Pipelines\n\n### Checking Out Code\n\n```yaml\n# Basic checkout\n- name: Checkout repository\n  uses: actions/checkout@v3\n\n# Checkout with full history\n- name: Checkout with history\n  uses: actions/checkout@v3\n  with:\n    fetch-depth: 0\n\n# Checkout specific branch\n- name: Checkout specific branch\n  uses: actions/checkout@v3\n  with:\n    ref: develop\n\n# Checkout multiple repositories\n- name: Checkout main repo\n  uses: actions/checkout@v3\n  with:\n    path: main\n\n- name: Checkout shared library\n  uses: actions/checkout@v3\n  with:\n    repository: myorg/shared-library\n    path: shared\n    token: ${{ secrets.ACCESS_TOKEN }}\n```\n\n### Git Information in Builds\n\n```bash\n#!/bin/bash\n# build-info.sh - Extract Git information for builds\n\n# Get current commit hash\nCOMMIT_HASH=$(git rev-parse --short HEAD)\n\n# Get current branch\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\n\n# Get commit count\nCOMMIT_COUNT=$(git rev-list --count HEAD)\n\n# Get last tag\nLAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo \"v0.0.0\")\n\n# Build version string\nVERSION=\"${LAST_TAG}-${COMMIT_COUNT}-${COMMIT_HASH}\"\n\necho \"Building version: $VERSION\"\necho \"Branch: $BRANCH\"\necho \"Commit: $COMMIT_HASH\"\n\n# Write to file for other build steps\necho \"VERSION=$VERSION\" >> build.env\necho \"BRANCH=$BRANCH\" >> build.env\necho \"COMMIT_HASH=$COMMIT_HASH\" >> build.env\n```\n\n## Monorepo Strategies\n\n### Path-based Triggers\n\n```yaml\n# Only run when specific paths change\nname: Backend CI\non:\n  push:\n    paths:\n      - 'backend/**'\n      - '.github/workflows/backend.yml'\n  pull_request:\n    paths:\n      - 'backend/**'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check changed files\n        id: changes\n        run: |\n          if git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -q '^backend/'; then\n            echo \"backend_changed=true\" >> $GITHUB_OUTPUT\n          fi\n          \n      - name: Run backend tests\n        if: steps.changes.outputs.backend_changed == 'true'\n        run: cd backend && npm test\n```\n\n### Selective Deployment\n\n```yaml\n# Deploy only changed services\nname: Selective Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  detect-changes:\n    runs-on: ubuntu-latest\n    outputs:\n      frontend: ${{ steps.changes.outputs.frontend }}\n      backend: ${{ steps.changes.outputs.backend }}\n      database: ${{ steps.changes.outputs.database }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dorny/paths-filter@v2\n        id: changes\n        with:\n          filters: |\n            frontend:\n              - 'frontend/**'\n            backend:\n              - 'backend/**'\n            database:\n              - 'database/**'\n              \n  deploy-frontend:\n    needs: detect-changes\n    if: needs.detect-changes.outputs.frontend == 'true'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy Frontend\n        run: echo \"Deploying frontend\"\n        \n  deploy-backend:\n    needs: detect-changes\n    if: needs.detect-changes.outputs.backend == 'true'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy Backend\n        run: echo \"Deploying backend\"\n```\n\n## Challenge: Create a Git-based CI/CD Workflow\n\nNow it's your turn! Create a complete CI/CD workflow that:\n\n1. Runs tests on pull requests\n2. Deploys to staging on merge to develop\n3. Deploys to production on tag creation\n4. Uses semantic versioning\n5. Includes rollback capabilities\n\n### Your Task\n\nWrite a GitHub Actions workflow file that implements the above requirements. Consider:\n\n- Branch protection rules\n- Environment-specific secrets\n- Approval processes for production\n- Automated rollback on failure\n- Notification mechanisms\n\n### Starter Template\n\n```yaml\nname: Complete CI/CD\non:\n  # Add your triggers here\n\njobs:\n  # Add your jobs here\n  test:\n    # Implement testing job\n    \n  deploy-staging:\n    # Implement staging deployment\n    \n  deploy-production:\n    # Implement production deployment\n    \n  rollback:\n    # Implement rollback mechanism\n```\n\nThis exercise will help you understand how Git integrates with modern CI/CD practices and how to design robust deployment pipelines.",
      "resources": [
        {
          "title": "GitHub Actions Documentation",
          "url": "https://docs.github.com/en/actions",
          "type": "documentation"
        },
        {
          "title": "Semantic Release",
          "url": "https://semantic-release.gitbook.io/",
          "type": "documentation"
        },
        {
          "title": "Conventional Commits",
          "url": "https://www.conventionalcommits.org/",
          "type": "documentation"
        }
      ]
    },
    {
      "id": "devops-git-5",
      "title": "Git Security & Best Practices",
      "type": "text",
      "content": "# Git Security & Best Practices\n\nSecurity is paramount in DevOps environments. Git repositories often contain sensitive information and serve as the foundation for automated deployments, making them attractive targets for attackers.\n\n## Git Security Fundamentals\n\n### 1. Repository Access Control\n\n**Branch Protection Rules:**\n- Require pull request reviews before merging\n- Require status checks to pass before merging\n- Require branches to be up to date before merging\n- Restrict pushes to main/master branches\n- Require signed commits for sensitive repositories\n\n**User Access Management:**\n```bash\n# Add user with read access\ngit remote set-url origin https://username:"
    }
  ],
  "resources": [
    {
      "title": "Git Security Best Practices",
      "url": "https://www.git-tower.com/learn/git/ebook/en/command-line/advanced-topics/git-security",
      "type": "article"
    },
    {
      "title": "GitHub Security Best Practices",
      "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/github-security-best-practices",
      "type": "documentation"
    }
  ]
}