{
  "id": "devops-github-actions",
  "title": "GitHub Actions Fundamentals",
  "description": "Master GitHub Actions for building robust CI/CD pipelines, automated testing, and deployment workflows",
  "order": 4,
  "estimatedMinutes": 90,
  "lessons": [
    {
      "id": "devops-actions-1",
      "title": "Introduction to GitHub Actions",
      "type": "text",
      "content": "# Introduction to GitHub Actions\n\nGitHub Actions is a powerful CI/CD platform that allows you to automate your software development workflows directly in your GitHub repository. It's event-driven, meaning workflows run in response to events like pushes, pull requests, or scheduled times.\n\n## Core Concepts\n\n### 1. Workflows\nWorkflows are automated processes defined in YAML files stored in `.github/workflows/`. They consist of one or more jobs that run when triggered by events.\n\n### 2. Events\nEvents are specific activities that trigger workflows:\n- **push**: Code pushed to repository\n- **pull_request**: PR opened, updated, or closed\n- **schedule**: Run on a schedule (cron syntax)\n- **workflow_dispatch**: Manual trigger\n- **release**: Release created or published\n\n### 3. Jobs\nJobs are sets of steps that execute on the same runner. By default, jobs run in parallel unless dependencies are specified.\n\n### 4. Steps\nSteps are individual tasks within a job. They can run commands or use actions (reusable units of code).\n\n### 5. Runners\nRunners are servers that execute workflows. GitHub provides hosted runners (Ubuntu, Windows, macOS) or you can use self-hosted runners.\n\n## Basic Workflow Structure\n\n```yaml\nname: CI/CD Pipeline\n\n# Events that trigger the workflow\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\n# Jobs to run\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run tests\n        run: npm test\n```\n\n## Workflow Syntax Overview\n\n### Event Triggers\n\n```yaml\n# Single event\non: push\n\n# Multiple events\non: [push, pull_request]\n\n# Event with conditions\non:\n  push:\n    branches: [main, 'release/*']\n    paths: ['src/**', '!docs/**']\n  pull_request:\n    types: [opened, synchronize, reopened]\n    \n# Scheduled workflows\non:\n  schedule:\n    - cron: '0 2 * * 1-5'  # 2 AM, Monday to Friday\n    \n# Manual trigger\non:\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: 'Environment to deploy to'\n        required: true\n        default: 'staging'\n        type: choice\n        options:\n          - staging\n          - production\n```\n\n### Job Configuration\n\n```yaml\njobs:\n  build:\n    name: Build Application\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    \n    # Set environment variables\n    env:\n      NODE_ENV: production\n      API_URL: https://api.example.com\n      \n    # Define job outputs\n    outputs:\n      version: ${{ steps.version.outputs.version }}\n      \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        \n      - name: Get version\n        id: version\n        run: echo \"version=$(cat package.json | jq -r '.version')\" >> $GITHUB_OUTPUT\n```\n\n### Step Types\n\n```yaml\nsteps:\n  # Using an action\n  - name: Setup Node.js\n    uses: actions/setup-node@v3\n    with:\n      node-version: '18'\n      cache: 'npm'\n      \n  # Running commands\n  - name: Install dependencies\n    run: |\n      npm ci\n      npm run build\n      \n  # Conditional steps\n  - name: Deploy to staging\n    if: github.ref == 'refs/heads/develop'\n    run: npm run deploy:staging\n    \n  # Using environment variables\n  - name: Build with environment\n    run: npm run build\n    env:\n      NODE_ENV: production\n      API_KEY: ${{ secrets.API_KEY }}\n```\n\n## GitHub Actions Marketplace\n\nThe GitHub Marketplace offers thousands of pre-built actions:\n\n### Popular Actions\n\n1. **actions/checkout@v3**: Check out repository code\n2. **actions/setup-node@v3**: Set up Node.js environment\n3. **actions/cache@v3**: Cache dependencies and build outputs\n4. **actions/upload-artifact@v3**: Upload build artifacts\n5. **docker/build-push-action@v4**: Build and push Docker images\n\n### Using Marketplace Actions\n\n```yaml\nsteps:\n  - name: Checkout repository\n    uses: actions/checkout@v3\n    \n  - name: Setup Python\n    uses: actions/setup-python@v4\n    with:\n      python-version: '3.9'\n      \n  - name: Cache pip dependencies\n    uses: actions/cache@v3\n    with:\n      path: ~/.cache/pip\n      key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n      restore-keys: |\n        ${{ runner.os }}-pip-\n```\n\n## Workflow Examples\n\n### Basic Node.js CI\n\n```yaml\nname: Node.js CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    strategy:\n      matrix:\n        node-version: [16, 18, 20]\n        \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: 'npm'\n          \n      - run: npm ci\n      - run: npm run build --if-present\n      - run: npm test\n```\n\n### Python CI with Multiple OS\n\n```yaml\nname: Python CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    \n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: ['3.8', '3.9', '3.10']\n        \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n          \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n          \n      - name: Test with pytest\n        run: |\n          pip install pytest\n          pytest\n```\n\n## Best Practices\n\n### 1. Workflow Organization\n- Use descriptive workflow and job names\n- Group related workflows in the same file\n- Use consistent naming conventions\n- Add comments for complex logic\n\n### 2. Performance Optimization\n- Use caching for dependencies\n- Parallelize independent jobs\n- Use appropriate runner types\n- Set reasonable timeouts\n\n### 3. Security Considerations\n- Use secrets for sensitive data\n- Pin action versions to specific commits\n- Limit workflow permissions\n- Review third-party actions before use\n\n### 4. Debugging and Monitoring\n- Use meaningful step names\n- Add debugging outputs when needed\n- Monitor workflow run times\n- Set up notifications for failures\n\nGitHub Actions provides a robust foundation for implementing DevOps practices. In the next lesson, we'll dive deeper into building complex CI/CD workflows.",
      "resources": [
        {
          "title": "GitHub Actions Documentation",
          "url": "https://docs.github.com/en/actions",
          "type": "documentation"
        },
        {
          "title": "GitHub Actions Marketplace",
          "url": "https://github.com/marketplace?type=actions",
          "type": "github"
        }
      ]
    },
    {
      "id": "devops-actions-2",
      "title": "Building CI/CD Pipelines",
      "type": "code",
      "content": "# Building CI/CD Pipelines with GitHub Actions\n\nIn this lesson, we'll build comprehensive CI/CD pipelines that cover testing, building, security scanning, and deployment across multiple environments.\n\n## Complete CI/CD Workflow Structure\n\nA robust CI/CD pipeline typically includes these stages:\n\n1. **Code Quality**: Linting, formatting, security scanning\n2. **Testing**: Unit, integration, and end-to-end tests\n3. **Building**: Compile, bundle, and package applications\n4. **Security**: Vulnerability scanning, dependency auditing\n5. **Deployment**: Deploy to staging and production environments\n\n## Multi-Environment Deployment Pipeline\n\n```yaml\nname: Full CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n  release:\n    types: [published]\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  # Code quality and security checks\n  quality:\n    name: Code Quality & Security\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # Full history for better analysis\n          \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run linting\n        run: npm run lint\n        \n      - name: Check code formatting\n        run: npm run format:check\n        \n      - name: Security audit\n        run: npm audit --audit-level=high\n        \n      - name: Run CodeQL Analysis\n        uses: github/codeql-action/analyze@v2\n        with:\n          languages: javascript\n\n  # Test suite\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    needs: quality\n    \n    strategy:\n      matrix:\n        node-version: [16, 18, 20]\n        \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: 'npm'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run unit tests\n        run: npm run test:unit\n        \n      - name: Run integration tests\n        run: npm run test:integration\n        \n      - name: Generate coverage report\n        run: npm run test:coverage\n        \n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage/lcov.info\n          flags: unittests\n          name: codecov-umbrella\n\n  # Build application\n  build:\n    name: Build Application\n    runs-on: ubuntu-latest\n    needs: [quality, test]\n    outputs:\n      image-digest: ${{ steps.build.outputs.digest }}\n      version: ${{ steps.version.outputs.version }}\n      \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Build application\n        run: npm run build\n        \n      - name: Get version\n        id: version\n        run: |\n          if [[ $GITHUB_REF == refs/tags/* ]]; then\n            VERSION=${GITHUB_REF#refs/tags/}\n          else\n            VERSION=${GITHUB_SHA::8}\n          fi\n          echo \"version=$VERSION\" >> $GITHUB_OUTPUT\n          \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n        \n      - name: Login to Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n          \n      - name: Build and push Docker image\n        id: build\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: |\n            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}\n            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n          \n      - name: Upload build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: dist-files\n          path: dist/\n          retention-days: 30\n\n  # Deploy to staging\n  deploy-staging:\n    name: Deploy to Staging\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.ref == 'refs/heads/develop'\n    environment:\n      name: staging\n      url: https://staging.example.com\n      \n    steps:\n      - name: Deploy to staging\n        run: |\n          echo \"Deploying version ${{ needs.build.outputs.version }} to staging\"\n          # Add your staging deployment commands here\n          \n      - name: Run smoke tests\n        run: |\n          echo \"Running smoke tests on staging\"\n          # Add smoke test commands\n          \n      - name: Notify team\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          channel: '#deployments'\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n\n  # Deploy to production\n  deploy-production:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.event_name == 'release'\n    environment:\n      name: production\n      url: https://example.com\n      \n    steps:\n      - name: Deploy to production\n        run: |\n          echo \"Deploying version ${{ needs.build.outputs.version }} to production\"\n          # Add your production deployment commands here\n          \n      - name: Run health checks\n        run: |\n          echo \"Running health checks on production\"\n          # Add health check commands\n          \n      - name: Update deployment status\n        uses: bobheadxi/deployments@v1\n        with:\n          step: finish\n          token: ${{ secrets.GITHUB_TOKEN }}\n          status: ${{ job.status }}\n          deployment_id: ${{ steps.deployment.outputs.deployment_id }}\n```\n\n## Advanced Pipeline Patterns\n\n### 1. Matrix Builds\n\nTest across multiple environments:\n\n```yaml\njobs:\n  test:\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        node-version: [16, 18, 20]\n        include:\n          - os: ubuntu-latest\n            node-version: 18\n            coverage: true\n        exclude:\n          - os: windows-latest\n            node-version: 16\n            \n    runs-on: ${{ matrix.os }}\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          \n      - name: Run tests\n        run: npm test\n        \n      - name: Upload coverage\n        if: matrix.coverage\n        uses: codecov/codecov-action@v3\n```\n\n### 2. Conditional Workflows\n\n```yaml\njobs:\n  check-changes:\n    runs-on: ubuntu-latest\n    outputs:\n      frontend: ${{ steps.changes.outputs.frontend }}\n      backend: ${{ steps.changes.outputs.backend }}\n      docs: ${{ steps.changes.outputs.docs }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: dorny/paths-filter@v2\n        id: changes\n        with:\n          filters: |\n            frontend:\n              - 'frontend/**'\n            backend:\n              - 'backend/**'\n            docs:\n              - 'docs/**'\n              - '*.md'\n\n  test-frontend:\n    needs: check-changes\n    if: needs.check-changes.outputs.frontend == 'true'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Test frontend\n        run: echo \"Testing frontend changes\"\n        \n  test-backend:\n    needs: check-changes\n    if: needs.check-changes.outputs.backend == 'true'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Test backend\n        run: echo \"Testing backend changes\"\n```\n\n### 3. Parallel and Sequential Jobs\n\n```yaml\njobs:\n  # These jobs run in parallel\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Lint code\n        run: npm run lint\n        \n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run tests\n        run: npm test\n        \n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Security scan\n        run: npm audit\n        \n  # This job waits for all above jobs to complete\n  build:\n    needs: [lint, test, security]\n    runs-on: ubuntu-latest\n    steps:\n      - name: Build application\n        run: npm run build\n        \n  # This job runs after build completes\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - name: Deploy to production\n        run: echo \"Deploying to production\"\n```\n\n## Docker Integration\n\n### Multi-stage Docker Build\n\n```yaml\nname: Docker Build and Deploy\n\non:\n  push:\n    branches: [main]\n    tags: ['v*']\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n      \n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n        \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n        \n      - name: Log in to Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n          \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            \n      - name: Build and push Docker image\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          platforms: linux/amd64,linux/arm64\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n```\n\n### Docker Compose Testing\n\n```yaml\nname: Integration Tests\n\non: [push, pull_request]\n\njobs:\n  integration:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: testdb\n        options: >\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n          \n      redis:\n        image: redis:7\n        options: >\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n          \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run migrations\n        run: npm run migrate\n        env:\n          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb\n          \n      - name: Run integration tests\n        run: npm run test:integration\n        env:\n          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb\n          REDIS_URL: redis://localhost:6379\n```\n\n## Secrets and Environment Management\n\n### Using Repository Secrets\n\n```yaml\nsteps:\n  - name: Deploy to AWS\n    env:\n      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}\n      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n      AWS_REGION: us-east-1\n    run: |\n      aws s3 sync dist/ s3://my-bucket/\n      \n  - name: Notify Slack\n    uses: 8398a7/action-slack@v3\n    with:\n      status: ${{ job.status }}\n      webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n### Environment-specific Deployments\n\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [staging, production]\n        \n    environment:\n      name: ${{ matrix.environment }}\n      url: ${{ steps.deploy.outputs.url }}\n      \n    steps:\n      - name: Deploy to ${{ matrix.environment }}\n        id: deploy\n        run: |\n          echo \"Deploying to ${{ matrix.environment }}\"\n          \n          if [ \"${{ matrix.environment }}\" == \"production\" ]; then\n            URL=\"https://example.com\"\n          else\n            URL=\"https://staging.example.com\"\n          fi\n          \n          echo \"url=$URL\" >> $GITHUB_OUTPUT\n```\n\n## Monitoring and Notifications\n\n### Workflow Monitoring\n\n```yaml\nname: Workflow Monitoring\n\non:\n  workflow_run:\n    workflows: [\"CI/CD Pipeline\"]\n    types: [completed]\n\njobs:\n  monitor:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Check workflow status\n        run: |\n          if [ \"${{ github.event.workflow_run.conclusion }}\" == \"failure\" ]; then\n            echo \"Workflow failed! Sending alerts...\"\n            # Send alerts to monitoring systems\n          fi\n          \n      - name: Update status page\n        if: github.event.workflow_run.conclusion == 'failure'\n        run: |\n          # Update external status page\n          curl -X POST https://status.example.com/api/incidents \\\n            -H \"Authorization: Bearer ${{ secrets.STATUS_API_TOKEN }}\" \\\n            -d '{\"title\": \"Build Pipeline Failure\", \"status\": \"investigating\"}'\n```\n\n### Advanced Notifications\n\n```yaml\nsteps:\n  - name: Slack Notification\n    if: always()\n    uses: 8398a7/action-slack@v3\n    with:\n      status: custom\n      fields: repo,message,commit,author,action,eventName,ref,workflow\n      custom_payload: |\n        {\n          attachments: [{\n            color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',\n            title: '${{ github.workflow }} - ${{ job.status }}',\n            text: `Repository: ${process.env.AS_REPO}\\nCommit: ${process.env.AS_COMMIT}\\nAuthor: ${process.env.AS_AUTHOR}\\nBranch: ${process.env.AS_REF}`,\n            fields: [{\n              title: 'Workflow',\n              value: '${{ github.workflow }}',\n              short: true\n            }, {\n              title: 'Job',\n              value: '${{ github.job }}',\n              short: true\n            }]\n          }]\n        }\n    env:\n      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n## Performance Optimization\n\n### Caching Strategies\n\n```yaml\nsteps:\n  # Cache node_modules\n  - name: Cache Node.js dependencies\n    uses: actions/cache@v3\n    with:\n      path: ~/.npm\n      key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n      restore-keys: |\n        ${{ runner.os }}-node-\n        \n  # Cache Docker layers\n  - name: Cache Docker layers\n    uses: actions/cache@v3\n    with:\n      path: /tmp/.buildx-cache\n      key: ${{ runner.os }}-buildx-${{ github.sha }}\n      restore-keys: |\n        ${{ runner.os }}-buildx-\n        \n  # Cache test results\n  - name: Cache test results\n    uses: actions/cache@v3\n    with:\n      path: |\n        coverage/\n        test-results.xml\n      key: ${{ runner.os }}-test-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.test.js') }}\n```\n\n### Artifact Management\n\n```yaml\nsteps:\n  - name: Upload build artifacts\n    uses: actions/upload-artifact@v3\n    with:\n      name: dist-${{ github.sha }}\n      path: |\n        dist/\n        build/\n      retention-days: 30\n      \n  - name: Download artifacts\n    uses: actions/download-artifact@v3\n    with:\n      name: dist-${{ github.sha }}\n      path: ./dist\n```\n\nThese patterns and examples provide a solid foundation for building robust CI/CD pipelines with GitHub Actions. The key is to start simple and gradually add complexity as your needs grow.",
      "codeExamples": [
        {
          "language": "yaml",
          "code": "name: Simple CI Pipeline\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run tests\n        run: npm test\n        \n      - name: Build application\n        run: npm run build",
          "title": "Basic CI Pipeline",
          "description": "A simple CI pipeline that runs tests and builds the application on every push and pull request"
        },
        {
          "language": "yaml",
          "code": "name: Deploy to Multiple Environments\n\non:\n  push:\n    branches:\n      - main\n      - develop\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        \n      - name: Deploy to staging\n        if: github.ref == 'refs/heads/develop'\n        run: echo \"Deploying to staging\"\n        \n      - name: Deploy to production\n        if: github.ref == 'refs/heads/main'\n        run: echo \"Deploying to production\"",
          "title": "Environment-based Deployment",
          "description": "Deploy to different environments based on the branch being pushed to"
        }
      ],
      "resources": [
        {
          "title": "GitHub Actions Workflow Syntax",
          "url": "https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions",
          "type": "documentation"
        },
        {
          "title": "Docker Build Push Action",
          "url": "https://github.com/docker/build-push-action",
          "type": "github"
        }
      ]
    },
    {
      "id": "devops-actions-3",
      "title": "Custom Actions and Reusability",
      "type": "interactive",
      "content": "# Custom Actions and Reusability\n\nCreating custom actions allows you to encapsulate complex logic, share workflows across repositories, and build reusable components for your CI/CD pipelines.\n\n## Types of Custom Actions\n\n### 1. JavaScript Actions\nRun directly on the runner, fastest execution:\n\n```javascript\n// action.yml\nname: 'Custom JavaScript Action'\ndescription: 'A custom action written in JavaScript'\ninputs:\n  name:\n    description: 'Name to greet'\n    required: true\n    default: 'World'\noutputs:\n  greeting:\n    description: 'The greeting message'\nruns:\n  using: 'node16'\n  main: 'index.js'\n```\n\n```javascript\n// index.js\nconst core = require('@actions/core');\nconst github = require('@actions/github');\n\ntry {\n  const nameToGreet = core.getInput('name');\n  console.log(`Hello ${nameToGreet}!`);\n  \n  const time = (new Date()).toTimeString();\n  core.setOutput('greeting', `Hello ${nameToGreet} at ${time}`);\n  \n  // Get the JSON webhook payload for the event that triggered the workflow\n  const payload = JSON.stringify(github.context.payload, undefined, 2);\n  console.log(`The event payload: ${payload}`);\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n\n### 2. Docker Actions\nRun in a Docker container, more flexibility:\n\n```yaml\n# action.yml\nname: 'Custom Docker Action'\ndescription: 'A custom action using Docker'\ninputs:\n  source-directory:\n    description: 'Source directory to process'\n    required: true\n    default: './src'\noutputs:\n  processed-files:\n    description: 'Number of files processed'\nruns:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - ${{ inputs.source-directory }}\n```\n\n```dockerfile\n# Dockerfile\nFROM alpine:latest\n\nRUN apk add --no-cache bash\n\nCOPY entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\n\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n```bash\n#!/bin/bash\n# entrypoint.sh\n\nSOURCE_DIR=$1\n\necho \"Processing files in: $SOURCE_DIR\"\n\n# Count files\nFILE_COUNT=$(find \"$SOURCE_DIR\" -type f | wc -l)\n\necho \"Found $FILE_COUNT files\"\necho \"processed-files=$FILE_COUNT\" >> $GITHUB_OUTPUT\n\necho \"Processing complete!\"\n```\n\n### 3. Composite Actions\nCombine multiple steps into a single action:\n\n```yaml\n# action.yml\nname: 'Setup Node.js with Cache'\ndescription: 'Setup Node.js with dependency caching'\ninputs:\n  node-version:\n    description: 'Node.js version to use'\n    required: true\n    default: '18'\n  working-directory:\n    description: 'Working directory'\n    required: false\n    default: '.'\nruns:\n  using: 'composite'\n  steps:\n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ inputs.node-version }}\n        \n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: |\n          ~/.npm\n          ${{ inputs.working-directory }}/node_modules\n        key: ${{ runner.os }}-node-${{ inputs.node-version }}-${{ hashFiles(format('{0}/package-lock.json', inputs.working-directory)) }}\n        restore-keys: |\n          ${{ runner.os }}-node-${{ inputs.node-version }}-\n          \n    - name: Install dependencies\n      run: npm ci\n      shell: bash\n      working-directory: ${{ inputs.working-directory }}\n```\n\n## Reusable Workflows\n\nShare entire workflows across repositories:\n\n### Reusable Workflow Definition\n\n```yaml\n# .github/workflows/reusable-ci.yml\nname: Reusable CI Workflow\n\non:\n  workflow_call:\n    inputs:\n      node-version:\n        required: false\n        type: string\n        default: '18'\n      working-directory:\n        required: false\n        type: string\n        default: '.'\n      run-security-scan:\n        required: false\n        type: boolean\n        default: true\n    secrets:\n      CODECOV_TOKEN:\n        required: false\n      SLACK_WEBHOOK:\n        required: false\n    outputs:\n      coverage-percentage:\n        description: 'Test coverage percentage'\n        value: ${{ jobs.test.outputs.coverage }}\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    outputs:\n      coverage: ${{ steps.coverage.outputs.percentage }}\n      \n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ inputs.node-version }}\n          cache: 'npm'\n          \n      - name: Install dependencies\n        run: npm ci\n        working-directory: ${{ inputs.working-directory }}\n        \n      - name: Run tests\n        run: npm run test:coverage\n        working-directory: ${{ inputs.working-directory }}\n        \n      - name: Extract coverage\n        id: coverage\n        run: |\n          COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')\n          echo \"percentage=$COVERAGE\" >> $GITHUB_OUTPUT\n        working-directory: ${{ inputs.working-directory }}\n        \n      - name: Upload coverage\n        if: secrets.CODECOV_TOKEN\n        uses: codecov/codecov-action@v3\n        with:\n          token: ${{ secrets.CODECOV_TOKEN }}\n          \n      - name: Security scan\n        if: inputs.run-security-scan\n        run: npm audit --audit-level=high\n        working-directory: ${{ inputs.working-directory }}\n        \n      - name: Notify on failure\n        if: failure() && secrets.SLACK_WEBHOOK\n        uses: 8398a7/action-slack@v3\n        with:\n          status: failure\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n### Using Reusable Workflows\n\n```yaml\n# .github/workflows/ci.yml\nname: CI Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  frontend-tests:\n    uses: ./.github/workflows/reusable-ci.yml\n    with:\n      node-version: '18'\n      working-directory: './frontend'\n      run-security-scan: true\n    secrets:\n      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}\n      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}\n      \n  backend-tests:\n    uses: ./.github/workflows/reusable-ci.yml\n    with:\n      node-version: '16'\n      working-directory: './backend'\n      run-security-scan: false\n    secrets:\n      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}\n      \n  report-coverage:\n    needs: [frontend-tests, backend-tests]\n    runs-on: ubuntu-latest\n    steps:\n      - name: Report coverage\n        run: |\n          echo \"Frontend coverage: ${{ needs.frontend-tests.outputs.coverage-percentage }}%\"\n          echo \"Backend coverage: ${{ needs.backend-tests.outputs.coverage-percentage }}%\"\n```\n\n## Advanced Action Patterns\n\n### Multi-Step Action with Error Handling\n\n```yaml\n# action.yml\nname: 'Deploy with Rollback'\ndescription: 'Deploy application with automatic rollback on failure'\ninputs:\n  app-name:\n    description: 'Application name'\n    required: true\n  version:\n    description: 'Version to deploy'\n    required: true\n  environment:\n    description: 'Target environment'\n    required: true\n  rollback-on-failure:\n    description: 'Enable automatic rollback'\n    required: false\n    default: 'true'\noutputs:\n  deployment-url:\n    description: 'URL of the deployed application'\n  previous-version:\n    description: 'Previous version (for rollback)'\nruns:\n  using: 'composite'\n  steps:\n    - name: Get current version\n      id: current\n      run: |\n        CURRENT=$(kubectl get deployment ${{ inputs.app-name }} -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d':' -f2)\n        echo \"version=$CURRENT\" >> $GITHUB_OUTPUT\n        echo \"previous-version=$CURRENT\" >> $GITHUB_OUTPUT\n      shell: bash\n      \n    - name: Deploy new version\n      id: deploy\n      run: |\n        echo \"Deploying ${{ inputs.app-name }}:${{ inputs.version }} to ${{ inputs.environment }}\"\n        kubectl set image deployment/${{ inputs.app-name }} ${{ inputs.app-name }}=${{ inputs.app-name }}:${{ inputs.version }}\n        kubectl rollout status deployment/${{ inputs.app-name }} --timeout=300s\n        \n        URL=\"https://${{ inputs.app-name }}-${{ inputs.environment }}.example.com\"\n        echo \"deployment-url=$URL\" >> $GITHUB_OUTPUT\n      shell: bash\n      \n    - name: Health check\n      id: health\n      run: |\n        sleep 30\n        curl -f ${{ steps.deploy.outputs.deployment-url }}/health || exit 1\n      shell: bash\n      \n    - name: Rollback on failure\n      if: failure() && inputs.rollback-on-failure == 'true'\n      run: |\n        echo \"Deployment failed, rolling back to ${{ steps.current.outputs.version }}\"\n        kubectl set image deployment/${{ inputs.app-name }} ${{ inputs.app-name }}=${{ inputs.app-name }}:${{ steps.current.outputs.version }}\n        kubectl rollout status deployment/${{ inputs.app-name }} --timeout=300s\n      shell: bash\n```\n\n## Challenge: Build a Custom Deployment Action\n\nYour task is to create a custom composite action that:\n\n1. **Builds a Docker image** with proper tagging\n2. **Pushes to a registry** with authentication\n3. **Deploys to Kubernetes** with health checks\n4. **Sends notifications** on success/failure\n5. **Handles rollbacks** automatically\n\n### Requirements:\n\n- Accept inputs for image name, version, environment\n- Support multiple container registries\n- Include comprehensive error handling\n- Provide detailed outputs for downstream jobs\n- Add proper logging and debugging\n\n### Starter Template:\n\n```yaml\nname: 'Advanced Deployment Action'\ndescription: 'Deploy applications with comprehensive features'\ninputs:\n  # Add your inputs here\noutputs:\n  # Add your outputs here\nruns:\n  using: 'composite'\n  steps:\n    # Implement your deployment logic\n```\n\n### Bonus Features:\n\n- Blue-green deployment support\n- Canary deployment options\n- Integration with monitoring systems\n- Slack/Teams notifications\n- Deployment metrics collection\n\nThis exercise will help you understand how to create production-ready, reusable actions that can be shared across multiple projects and teams.",
      "resources": [
        {
          "title": "Creating Custom Actions",
          "url": "https://docs.github.com/en/actions/creating-actions",
          "type": "documentation"
        },
        {
          "title": "Reusing Workflows",
          "url": "https://docs.github.com/en/actions/using-workflows/reusing-workflows",
          "type": "documentation"
        },
        {
          "title": "Actions Toolkit",
          "url": "https://github.com/actions/toolkit",
          "type": "github"
        }
      ]
    }
  ],
  "quiz": {
    "id": "devops-github-actions-quiz",
    "questions": [
      {
        "id": "actions-q1",
        "question": "What is the correct way to make a job wait for multiple other jobs to complete?",
        "options": [
          "Use the 'depends-on' keyword",
          "Use the 'needs' keyword with an array",
          "Use the 'after' keyword",
          "Jobs automatically wait for previous jobs"
        ],
        "correctAnswer": 1,
        "explanation": "The 'needs' keyword is used to create dependencies between jobs. You can specify multiple jobs as an array: needs: [job1, job2, job3]"
      },
      {
        "id": "actions-q2",
        "question": "Which runner type should you choose for building Docker images with multi-platform support?",
        "options": [
          "windows-latest",
          "macos-latest",
          "ubuntu-latest",
          "self-hosted"
        ],
        "correctAnswer": 2,
        "explanation": "ubuntu-latest is the best choice for Docker builds as it has excellent Docker support and can build multi-platform images using Docker Buildx."
      },
      {
        "id": "actions-q3",
        "question": "What is the primary benefit of using matrix strategies in GitHub Actions?",
        "options": [
          "Faster execution time",
          "Better security",
          "Testing across multiple configurations in parallel",
          "Reduced resource usage"
        ],
        "correctAnswer": 2,
        "explanation": "Matrix strategies allow you to test your code across multiple configurations (OS, language versions, etc.) in parallel, ensuring compatibility across different environments."
      },
      {
        "id": "actions-q4",
        "question": "When should you use a composite action instead of a JavaScript action?",
        "options": [
          "When you need the fastest execution",
          "When you want to combine multiple existing actions",
          "When you need to access the GitHub API",
          "When you need to handle secrets"
        ],
        "correctAnswer": 1,
        "explanation": "Composite actions are ideal for combining multiple existing actions and steps into a single reusable action, making workflows more modular and maintainable."
      },
      {
        "id": "actions-q5",
        "question": "What is the correct way to securely use sensitive data in GitHub Actions?",
        "options": [
          "Store in environment variables in the workflow file",
          "Use GitHub Secrets and reference them with ${{ secrets.SECRET_NAME }}",
          "Hardcode them in the action code",
          "Pass them as workflow inputs"
        ],
        "correctAnswer": 1,
        "explanation": "GitHub Secrets should be used for sensitive data and referenced using ${{ secrets.SECRET_NAME }}. This ensures the data is encrypted and not exposed in logs."
      }
    ],
    "passingScore": 4
  }
}