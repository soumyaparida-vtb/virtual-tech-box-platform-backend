{
  "id": "devops-terraform",
  "title": "Infrastructure as Code with Terraform",
  "description": "Learn to provision and manage cloud infrastructure using Terraform, enabling repeatable, version-controlled infrastructure deployments",
  "order": 5,
  "estimatedMinutes": 85,
  "lessons": [
    {
      "id": "devops-terraform-1",
      "title": "Introduction to Infrastructure as Code",
      "type": "text",
      "content": "# Introduction to Infrastructure as Code (IaC)\n\nInfrastructure as Code (IaC) is the practice of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.\n\n## Why Infrastructure as Code?\n\n### Traditional Infrastructure Management Problems\n\n- **Manual Configuration**: Error-prone, time-consuming manual setup\n- **Configuration Drift**: Environments diverge over time\n- **Lack of Version Control**: No history of infrastructure changes\n- **Poor Documentation**: Infrastructure setup not properly documented\n- **Inconsistent Environments**: Dev, staging, and production differ\n- **Scaling Challenges**: Difficult to replicate infrastructure\n\n### Benefits of Infrastructure as Code\n\n1. **Consistency**: Identical infrastructure across environments\n2. **Version Control**: Track all infrastructure changes\n3. **Automation**: Reduce manual errors and save time\n4. **Documentation**: Infrastructure code serves as documentation\n5. **Disaster Recovery**: Quickly rebuild infrastructure\n6. **Cost Management**: Better resource utilization and tracking\n7. **Collaboration**: Teams can work together on infrastructure\n\n## IaC Approaches\n\n### 1. Imperative vs Declarative\n\n**Imperative (How):**\n```bash\n# Bash script approach\naws ec2 run-instances --image-id ami-12345 --count 1 --instance-type t2.micro\naws ec2 create-security-group --group-name web-sg --description \"Web security group\"\naws ec2 authorize-security-group-ingress --group-name web-sg --protocol tcp --port 80 --cidr 0.0.0.0/0\n```\n\n**Declarative (What):**\n```hcl\n# Terraform approach\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-12345\"\n  instance_type = \"t2.micro\"\n  \n  vpc_security_group_ids = [aws_security_group.web.id]\n}\n\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"web-sg\"\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n### 2. Mutable vs Immutable Infrastructure\n\n**Mutable Infrastructure:**\n- Servers are updated in-place\n- Risk of configuration drift\n- Harder to troubleshoot\n\n**Immutable Infrastructure:**\n- New servers replace old ones\n- Consistent deployments\n- Easier rollbacks\n\n## Popular IaC Tools\n\n| **Tool** | **Type** | **Cloud Support** | **Language** | **Best For** |\n|----------|----------|-------------------|--------------|---------------|\n| Terraform | Declarative | Multi-cloud | HCL | Multi-cloud deployments |\n| CloudFormation | Declarative | AWS only | JSON/YAML | AWS-native projects |\n| Pulumi | Declarative | Multi-cloud | Python/TypeScript/Go | Developers familiar with programming |\n| Ansible | Imperative | Multi-cloud | YAML | Configuration management |\n| ARM Templates | Declarative | Azure only | JSON | Azure-native projects |\n\n## Terraform Overview\n\nTerraform is an open-source infrastructure as code software tool created by HashiCorp. It enables users to define and provision data center infrastructure using a high-level configuration language.\n\n### Key Features\n\n1. **Multi-Cloud Support**: Works with AWS, Azure, GCP, and 100+ providers\n2. **State Management**: Tracks infrastructure state for consistency\n3. **Plan and Apply**: Preview changes before applying them\n4. **Resource Graph**: Understands dependencies between resources\n5. **Module System**: Reusable infrastructure components\n6. **Provider Ecosystem**: Extensive third-party provider support\n\n### Terraform Workflow\n\n```mermaid\ngraph LR\n    A[Write Configuration] --> B[terraform init]\n    B --> C[terraform plan]\n    C --> D[terraform apply]\n    D --> E[Infrastructure Provisioned]\n    E --> F[terraform destroy]\n    \n    C --> G[Review Changes]\n    G --> C\n```\n\n1. **Write**: Define infrastructure in `.tf` files\n2. **Init**: Initialize working directory and download providers\n3. **Plan**: Preview what Terraform will create/modify/destroy\n4. **Apply**: Execute the planned changes\n5. **Destroy**: Remove infrastructure when no longer needed\n\n## Infrastructure Lifecycle Management\n\n### Environment Management\n\n```\nProject Structure:\n├── environments/\n│   ├── dev/\n│   │   ├── main.tf\n│   │   ├── variables.tf\n│   │   └── terraform.tfvars\n│   ├── staging/\n│   │   ├── main.tf\n│   │   ├── variables.tf\n│   │   └── terraform.tfvars\n│   └── production/\n│       ├── main.tf\n│       ├── variables.tf\n│       └── terraform.tfvars\n└── modules/\n    ├── vpc/\n    ├── ec2/\n    └── rds/\n```\n\n### Change Management Process\n\n1. **Planning**: Design infrastructure changes\n2. **Review**: Peer review of infrastructure code\n3. **Testing**: Validate changes in non-production\n4. **Approval**: Get stakeholder approval\n5. **Deployment**: Apply changes to production\n6. **Monitoring**: Verify successful deployment\n\n## Best Practices for IaC\n\n### 1. Version Control Everything\n- Store all IaC code in Git repositories\n- Use meaningful commit messages\n- Tag releases and versions\n- Implement code review processes\n\n### 2. Environment Separation\n- Separate configurations for each environment\n- Use different state files for each environment\n- Implement proper access controls\n\n### 3. Documentation\n- Document infrastructure decisions\n- Use descriptive resource names\n- Add comments to complex configurations\n- Maintain architecture diagrams\n\n### 4. Testing\n- Validate syntax and formatting\n- Test in non-production environments first\n- Use infrastructure testing tools\n- Implement automated compliance checks\n\n### 5. Security\n- Use least privilege access\n- Encrypt sensitive data\n- Scan for security vulnerabilities\n- Implement proper secret management\n\nInfrastructure as Code transforms how we manage infrastructure, making it more reliable, scalable, and maintainable. In the next lesson, we'll dive into Terraform basics and start building our first infrastructure.",
      "resources": [
        {
          "title": "Infrastructure as Code Principles",
          "url": "https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/infrastructure-as-code.html",
          "type": "documentation"
        },
        {
          "title": "Terraform Documentation",
          "url": "https://developer.hashicorp.com/terraform/docs",
          "type": "documentation"
        }
      ]
    },
    {
      "id": "devops-terraform-2",
      "title": "Terraform Fundamentals",
      "type": "code",
      "content": "# Terraform Fundamentals\n\nLet's dive into Terraform basics, understanding its core concepts and building your first infrastructure.\n\n## Terraform Configuration Language (HCL)\n\nTerraform uses HashiCorp Configuration Language (HCL), which is designed to be human-readable and machine-friendly.\n\n### Basic Syntax\n\n```hcl\n# This is a comment\n\n# Resource block\nresource \"resource_type\" \"resource_name\" {\n  argument1 = \"value1\"\n  argument2 = \"value2\"\n  \n  # Nested block\n  nested_block {\n    nested_argument = \"nested_value\"\n  }\n}\n\n# Variable definition\nvariable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t2.micro\"\n}\n\n# Output definition\noutput \"instance_ip\" {\n  description = \"Public IP of the instance\"\n  value       = aws_instance.web.public_ip\n}\n```\n\n## Core Terraform Concepts\n\n### 1. Providers\n\nProviders are plugins that interact with APIs of cloud platforms and services:\n\n```hcl\n# AWS Provider\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n  \n  required_version = \">= 1.0\"\n}\n\n# Configure the AWS Provider\nprovider \"aws\" {\n  region = var.aws_region\n  \n  default_tags {\n    tags = {\n      Environment = var.environment\n      Project     = \"terraform-tutorial\"\n      ManagedBy   = \"Terraform\"\n    }\n  }\n}\n```\n\n### 2. Resources\n\nResources are the most important element in Terraform language:\n\n```hcl\n# VPC Resource\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.project_name}-igw\"\n  }\n}\n\n# Public Subnet\nresource \"aws_subnet\" \"public\" {\n  count = length(var.availability_zones)\n  \n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.${count.index + 1}.0/24\"\n  availability_zone       = var.availability_zones[count.index]\n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.project_name}-public-${count.index + 1}\"\n    Type = \"Public\"\n  }\n}\n```\n\n### 3. Data Sources\n\nData sources allow you to fetch information from existing resources:\n\n```hcl\n# Get latest Amazon Linux 2 AMI\ndata \"aws_ami\" \"amazon_linux\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n  \n  filter {\n    name   = \"name\"\n    values = [\"amzn2-ami-hvm-*-x86_64-gp2\"]\n  }\n  \n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n}\n\n# Get current AWS region\ndata \"aws_region\" \"current\" {}\n\n# Get current AWS account ID\ndata \"aws_caller_identity\" \"current\" {}\n```\n\n### 4. Variables\n\n```hcl\n# variables.tf\nvariable \"aws_region\" {\n  description = \"AWS region for resources\"\n  type        = string\n  default     = \"us-west-2\"\n}\n\nvariable \"project_name\" {\n  description = \"Name of the project\"\n  type        = string\n  validation {\n    condition     = length(var.project_name) > 0\n    error_message = \"Project name cannot be empty.\"\n  }\n}\n\nvariable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t2.micro\"\n  \n  validation {\n    condition = contains([\n      \"t2.micro\", \"t2.small\", \"t2.medium\",\n      \"t3.micro\", \"t3.small\", \"t3.medium\"\n    ], var.instance_type)\n    error_message = \"Instance type must be a valid t2 or t3 instance type.\"\n  }\n}\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  \n  validation {\n    condition     = contains([\"dev\", \"staging\", \"production\"], var.environment)\n    error_message = \"Environment must be dev, staging, or production.\"\n  }\n}\n\nvariable \"availability_zones\" {\n  description = \"List of availability zones\"\n  type        = list(string)\n  default     = [\"us-west-2a\", \"us-west-2b\"]\n}\n\nvariable \"allowed_cidr_blocks\" {\n  description = \"CIDR blocks allowed to access the application\"\n  type        = list(string)\n  default     = [\"0.0.0.0/0\"]\n}\n```\n\n### 5. Outputs\n\n```hcl\n# outputs.tf\noutput \"vpc_id\" {\n  description = \"ID of the VPC\"\n  value       = aws_vpc.main.id\n}\n\noutput \"vpc_cidr_block\" {\n  description = \"CIDR block of the VPC\"\n  value       = aws_vpc.main.cidr_block\n}\n\noutput \"public_subnet_ids\" {\n  description = \"IDs of the public subnets\"\n  value       = aws_subnet.public[*].id\n}\n\noutput \"internet_gateway_id\" {\n  description = \"ID of the Internet Gateway\"\n  value       = aws_internet_gateway.main.id\n}\n\noutput \"instance_public_ip\" {\n  description = \"Public IP address of the EC2 instance\"\n  value       = aws_instance.web.public_ip\n  sensitive   = false\n}\n\noutput \"instance_private_ip\" {\n  description = \"Private IP address of the EC2 instance\"\n  value       = aws_instance.web.private_ip\n}\n```\n\n## Complete Example: Web Server Infrastructure\n\n### main.tf\n\n```hcl\n# main.tf\nterraform {\n  required_version = \">= 1.0\"\n  \n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n}\n\n# VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.project_name}-igw\"\n  }\n}\n\n# Public Subnet\nresource \"aws_subnet\" \"public\" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.1.0/24\"\n  availability_zone       = \"${var.aws_region}a\"\n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.project_name}-public-subnet\"\n  }\n}\n\n# Route Table\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-public-rt\"\n  }\n}\n\n# Route Table Association\nresource \"aws_route_table_association\" \"public\" {\n  subnet_id      = aws_subnet.public.id\n  route_table_id = aws_route_table.public.id\n}\n\n# Security Group\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"${var.project_name}-web-\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    description = \"HTTP\"\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_cidr_blocks\n  }\n  \n  ingress {\n    description = \"HTTPS\"\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = var.allowed_cidr_blocks\n  }\n  \n  ingress {\n    description = \"SSH\"\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/16\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-web-sg\"\n  }\n}\n\n# EC2 Instance\nresource \"aws_instance\" \"web\" {\n  ami                    = data.aws_ami.amazon_linux.id\n  instance_type          = var.instance_type\n  subnet_id              = aws_subnet.public.id\n  vpc_security_group_ids = [aws_security_group.web.id]\n  \n  user_data = <<-EOF\n              #!/bin/bash\n              yum update -y\n              yum install -y httpd\n              systemctl start httpd\n              systemctl enable httpd\n              echo \"<h1>Hello from Terraform!</h1>\" > /var/www/html/index.html\n              echo \"<p>Instance ID: $(curl -s http://169.254.169.254/latest/meta-data/instance-id)</p>\" >> /var/www/html/index.html\n              echo \"<p>Availability Zone: $(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone)</p>\" >> /var/www/html/index.html\n              EOF\n  \n  tags = {\n    Name = \"${var.project_name}-web-server\"\n  }\n}\n```\n\n### terraform.tfvars\n\n```hcl\n# terraform.tfvars\naws_region              = \"us-west-2\"\nproject_name           = \"my-web-app\"\ninstance_type          = \"t2.micro\"\nenvironment            = \"dev\"\nallowed_cidr_blocks    = [\"0.0.0.0/0\"]\n```\n\n## Terraform Commands\n\n### Basic Workflow\n\n```bash\n# Initialize the working directory\nterraform init\n\n# Format the configuration files\nterraform fmt\n\n# Validate the configuration\nterraform validate\n\n# Create execution plan\nterraform plan\n\n# Apply the changes\nterraform apply\n\n# Show current state\nterraform show\n\n# List resources in state\nterraform state list\n\n# Destroy infrastructure\nterraform destroy\n```\n\n### Advanced Commands\n\n```bash\n# Import existing infrastructure\nterraform import aws_instance.web i-1234567890abcdef0\n\n# Refresh state from real infrastructure\nterraform refresh\n\n# Target specific resources\nterraform apply -target=aws_instance.web\n\n# Use specific variable file\nterraform apply -var-file=\"production.tfvars\"\n\n# Set variables via command line\nterraform apply -var=\"instance_type=t2.small\"\n\n# Generate dependency graph\nterraform graph | dot -Tsvg > graph.svg\n```\n\n## State Management\n\nTerraform state is crucial for tracking infrastructure:\n\n```bash\n# View state\nterraform state show aws_instance.web\n\n# Remove resource from state (doesn't destroy)\nterraform state rm aws_instance.web\n\n# Move resource in state\nterraform state mv aws_instance.web aws_instance.web_server\n\n# Pull remote state\nterraform state pull\n\n# Push local state to remote\nterraform state push\n```\n\nThis foundation will enable you to start building and managing infrastructure with Terraform. In the next lesson, we'll explore advanced Terraform features and best practices.",
      "codeExamples": [
        {
          "language": "hcl",
          "code": "# Simple EC2 instance\nresource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c55b159cbfafe1d0\"\n  instance_type = \"t2.micro\"\n  \n  tags = {\n    Name = \"terraform-example\"\n  }\n}",
          "title": "Basic EC2 Instance",
          "description": "A simple Terraform configuration to create an EC2 instance"
        },
        {
          "language": "bash",
          "code": "# Terraform workflow commands\nterraform init     # Initialize working directory\nterraform plan     # Create execution plan\nterraform apply    # Apply changes\nterraform destroy  # Destroy infrastructure",
          "title": "Essential Terraform Commands",
          "description": "Core commands for the Terraform workflow"
        }
      ],
      "resources": [
        {
          "title": "Terraform Configuration Language",
          "url": "https://developer.hashicorp.com/terraform/language",
          "type": "documentation"
        },
        {
          "title": "AWS Provider Documentation",
          "url": "https://registry.terraform.io/providers/hashicorp/aws/latest/docs",
          "type": "documentation"
        }
      ]
    },
    {
      "id": "devops-terraform-3",
      "title": "Advanced Terraform Features",
      "type": "interactive",
      "content": "# Advanced Terraform Features\n\nNow that you understand Terraform basics, let's explore advanced features that make Terraform powerful for complex infrastructure management.\n\n## Modules\n\nModules are containers for multiple resources that are used together. They enable code reuse and organization.\n\n### Creating a VPC Module\n\n```hcl\n# modules/vpc/main.tf\nvariable \"cidr_block\" {\n  description = \"CIDR block for VPC\"\n  type        = string\n}\n\nvariable \"project_name\" {\n  description = \"Name of the project\"\n  type        = string\n}\n\nvariable \"availability_zones\" {\n  description = \"Available zones\"\n  type        = list(string)\n}\n\nvariable \"public_subnet_cidrs\" {\n  description = \"CIDR blocks for public subnets\"\n  type        = list(string)\n}\n\nvariable \"private_subnet_cidrs\" {\n  description = \"CIDR blocks for private subnets\"\n  type        = list(string)\n}\n\n# VPC\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.cidr_block\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.project_name}-igw\"\n  }\n}\n\n# Public Subnets\nresource \"aws_subnet\" \"public\" {\n  count = length(var.public_subnet_cidrs)\n  \n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = var.public_subnet_cidrs[count.index]\n  availability_zone       = var.availability_zones[count.index]\n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.project_name}-public-${count.index + 1}\"\n    Type = \"Public\"\n  }\n}\n\n# Private Subnets\nresource \"aws_subnet\" \"private\" {\n  count = length(var.private_subnet_cidrs)\n  \n  vpc_id            = aws_vpc.main.id\n  cidr_block        = var.private_subnet_cidrs[count.index]\n  availability_zone = var.availability_zones[count.index]\n  \n  tags = {\n    Name = \"${var.project_name}-private-${count.index + 1}\"\n    Type = \"Private\"\n  }\n}\n\n# NAT Gateway\nresource \"aws_eip\" \"nat\" {\n  count = length(var.public_subnet_cidrs)\n  \n  domain = \"vpc\"\n  \n  tags = {\n    Name = \"${var.project_name}-nat-eip-${count.index + 1}\"\n  }\n  \n  depends_on = [aws_internet_gateway.main]\n}\n\nresource \"aws_nat_gateway\" \"main\" {\n  count = length(var.public_subnet_cidrs)\n  \n  allocation_id = aws_eip.nat[count.index].id\n  subnet_id     = aws_subnet.public[count.index].id\n  \n  tags = {\n    Name = \"${var.project_name}-nat-${count.index + 1}\"\n  }\n}\n\n# Route Tables\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-public-rt\"\n  }\n}\n\nresource \"aws_route_table\" \"private\" {\n  count = length(var.private_subnet_cidrs)\n  \n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block     = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.main[count.index].id\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-private-rt-${count.index + 1}\"\n  }\n}\n\n# Route Table Associations\nresource \"aws_route_table_association\" \"public\" {\n  count = length(var.public_subnet_cidrs)\n  \n  subnet_id      = aws_subnet.public[count.index].id\n  route_table_id = aws_route_table.public.id\n}\n\nresource \"aws_route_table_association\" \"private\" {\n  count = length(var.private_subnet_cidrs)\n  \n  subnet_id      = aws_subnet.private[count.index].id\n  route_table_id = aws_route_table.private[count.index].id\n}\n```\n\n```hcl\n# modules/vpc/outputs.tf\noutput \"vpc_id\" {\n  description = \"ID of the VPC\"\n  value       = aws_vpc.main.id\n}\n\noutput \"vpc_cidr_block\" {\n  description = \"CIDR block of the VPC\"\n  value       = aws_vpc.main.cidr_block\n}\n\noutput \"public_subnet_ids\" {\n  description = \"IDs of the public subnets\"\n  value       = aws_subnet.public[*].id\n}\n\noutput \"private_subnet_ids\" {\n  description = \"IDs of the private subnets\"\n  value       = aws_subnet.private[*].id\n}\n\noutput \"internet_gateway_id\" {\n  description = \"ID of the Internet Gateway\"\n  value       = aws_internet_gateway.main.id\n}\n\noutput \"nat_gateway_ids\" {\n  description = \"IDs of the NAT Gateways\"\n  value       = aws_nat_gateway.main[*].id\n}\n```\n\n### Using the VPC Module\n\n```hcl\n# main.tf\nmodule \"vpc\" {\n  source = \"./modules/vpc\"\n  \n  cidr_block             = \"10.0.0.0/16\"\n  project_name           = var.project_name\n  availability_zones     = [\"us-west-2a\", \"us-west-2b\"]\n  public_subnet_cidrs    = [\"10.0.1.0/24\", \"10.0.2.0/24\"]\n  private_subnet_cidrs   = [\"10.0.10.0/24\", \"10.0.20.0/24\"]\n}\n\n# Use module outputs\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"web-sg-\"\n  vpc_id      = module.vpc.vpc_id\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n## Dynamic Blocks\n\nDynamic blocks allow you to dynamically construct repeatable nested blocks:\n\n```hcl\nvariable \"ingress_rules\" {\n  description = \"List of ingress rules\"\n  type        = list(object({\n    from_port   = number\n    to_port     = number\n    protocol    = string\n    cidr_blocks = list(string)\n  }))\n}\n\nresource \"aws_security_group\" \"web\" {\n  name_prefix = \"web-sg-\"\n  vpc_id      = aws_vpc.main.id\n  \n  dynamic \"ingress\" {\n    for_each = var.ingress_rules\n    content {\n      from_port   = ingress.value.from_port\n      to_port     = ingress.value.to_port\n      protocol    = ingress.value.protocol\n      cidr_blocks = ingress.value.cidr_blocks\n    }\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\""
    }
],
        "resources": [
            {
            "title": "Terraform Modules Documentation",
            "url": "https://developer.hashicorp.com/terraform/language/modules",
            "type": "documentation"
            },
            {
            "title": "Dynamic Blocks in Terraform",
            "url": "https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks",
            "type": "documentation"
            }
        ]
}
        
